-- This file has been automatically generated by go-iec61499-vhdl and should not be edited by hand
-- Converter written by Hammond Pearce and available at github.com/kiwih/go-iec61499-vhdl

-- This file represents the top level file for the IEC61499 network with DE2_115 as the top level block
-- This is the file that you should embed into your vhdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity iec61499_network_top is

	port(
		--for clock and reset signal
		clk		: in	std_logic;
		reset	: in	std_logic;
		
		--special emitted internal variables for child I/O
		rx_conveyor_moving : in std_logic; --type was BOOL 
		rx_conveyor_jammed : in std_logic; --type was BOOL 
		tx_conveyor_run : out std_logic; --type was BOOL 
		rx_global_run : in std_logic; --type was BOOL 
		rx_global_run_infinite : in std_logic; --type was BOOL 
		rx_global_fault : in std_logic; --type was BOOL 
		tx_box_dropper_run : out std_logic; --type was BOOL 
		
		
		--signals in case external components want to measure time
		debug_enable: out std_logic;
		debug_sync: out std_logic;
		debug_done: out std_logic
	);

end entity;

architecture rtl of iec61499_network_top is
	-- Build an enumerated type for the state machine
	type state_type is (STATE_sync, STATE_wait_sync_done, STATE_run, STATE_wait_run_done);

	-- Register to hold the current state
	signal state   : state_type := STATE_sync;

	signal enable : std_logic := '0';
	signal sync : std_logic := '0';
	signal done : std_logic := '0';
begin

	--port map for top level block
	top_block: entity work.DE2_115 port map(
		clk => clk,
		reset => reset,
		enable => enable,
		sync => sync,
		
		
		--special emitted internal variables for child I/O
		rx_conveyor_moving => rx_conveyor_moving, --going in 
		rx_conveyor_jammed => rx_conveyor_jammed, --going in 
		tx_conveyor_run => tx_conveyor_run, --going out 
		rx_global_run => rx_global_run, --going in 
		rx_global_run_infinite => rx_global_run_infinite, --going in 
		rx_global_fault => rx_global_fault, --going in 
		tx_box_dropper_run => tx_box_dropper_run, --going out 
		

		done => done
	);

	process (clk, reset)
	begin
		if reset = '1' then
			state <= STATE_sync;
		elsif (rising_edge(clk)) then
			--default values
			state <= state;
			enable <= '0';
			sync <= '0';		
			
			case state is
				when STATE_sync =>
					sync <= '1';
					state <= STATE_wait_sync_done;
				when STATE_wait_sync_done => --TODO sync_done signal
					state <= STATE_run;
				when STATE_run =>
					enable <= '1';
					state <= STATE_wait_run_done;
				when STATE_wait_run_done =>
					if done='1' then
						state <= STATE_sync;
					end if;
			end case;	
		end if;
	end process;

	debug_done <= done;
	debug_enable <= enable;
	debug_sync <= sync;

end rtl;
