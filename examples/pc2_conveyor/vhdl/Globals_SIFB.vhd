-- This file has been automatically generated by go-iec61499-vhdl and should not be edited by hand
-- Converter written by Hammond Pearce and available at github.com/kiwih/go-iec61499-vhdl

-- This file represents the Basic Function Block for Globals_SIFB

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;



entity Globals_SIFB is

	port(
		--for clock and reset signal
		clk		: in	std_logic;
		reset	: in	std_logic;
		enable	: in	std_logic;
		sync	: in	std_logic;
		
		
		--output events
		global_run_changed_eO : out std_logic;
		global_fault_changed_eO : out std_logic;
		
		
		
		--output variables
		global_run_O : out std_logic; --type was BOOL
		global_run_infinite_O : out std_logic; --type was BOOL
		global_fault_O : out std_logic; --type was BOOL
		
		
		--special emitted internal vars for I/O
		rx_global_run : in std_logic; --type was BOOL
		rx_global_run_infinite : in std_logic; --type was BOOL
		rx_global_fault : in std_logic; --type was BOOL
		
		--for done signal
		done : out std_logic
	);

end entity;


architecture rtl of Globals_SIFB is
	-- Build an enumerated type for the state machine
	type state_type is (STATE_Start);

	-- Register to hold the current state
	signal state   : state_type := STATE_Start;

	
	-- signals to rename outputs 
	signal global_run : std_logic := '0'; 
	signal global_run_infinite : std_logic := '0'; 
	signal global_fault : std_logic := '0'; 
	

	
	--signals to rename output events
	signal global_run_changed_eO_ecc_out : std_logic := '0'; --used when event driven from ECC (normal FB behaviour)
	signal global_run_changed_eO_alg_out : std_logic := '0'; --used when event driven from algorithm (normal SIFB behaviour)
	signal global_fault_changed_eO_ecc_out : std_logic := '0'; --used when event driven from ECC (normal FB behaviour)
	signal global_fault_changed_eO_alg_out : std_logic := '0'; --used when event driven from algorithm (normal SIFB behaviour)
	

	-- signals for enabling algorithms	
	signal globals_alg_alg_en : std_logic := '0'; 
	signal globals_alg_alg_done : std_logic := '1';
	

	-- signal for algorithm completion
	signal AlgorithmsStart : std_logic := '0';
	signal AlgorithmsDone : std_logic;

	--internal variables 
	signal rx_global_run_prev : std_logic; --type was BOOL 
	signal rx_global_run_infinite_prev : std_logic; --type was BOOL 
	signal rx_global_fault_prev : std_logic; --type was BOOL 
begin
	
	
	--output var renaming, no output registers as inputs are stored where they are processed
	global_run_O <= global_run;
	global_run_infinite_O <= global_run_infinite;
	global_fault_O <= global_fault;
			
	
	-- Logic to advance to the next state
	process (clk, reset)
	begin
		if reset = '1' then
			state <= STATE_Start;
			AlgorithmsStart <= '1';
		elsif (rising_edge(clk)) then
			if AlgorithmsStart = '1' then --algorithms should be triggered only once via this pulse signal
				AlgorithmsStart <= '0';
			elsif enable = '1' then 
				--default values
				state <= state;
				AlgorithmsStart <= '0';

				--next state logic
				--if AlgorithmsStart = '0' and AlgorithmsDone = '1' then
					case state is
						when STATE_Start =>
							if true then
								state <= STATE_Start;
								AlgorithmsStart <= '1';
							end if;
						
					end case;
				--end if;
			end if;
		end if;
	end process;

	-- Event outputs and internal algorithm triggers depend solely on the current state
	process (state)
	begin
		--default values
		--events
		global_run_changed_eO_ecc_out <= '0';
		global_fault_changed_eO_ecc_out <= '0';
		
		--algorithms
		globals_alg_alg_en <= '0'; 

		case state is
			when STATE_Start =>
				globals_alg_alg_en <= '1';
				
			
		end case;
	end process;

	-- Algorithms process
	process(clk)
	begin
		if rising_edge(clk) then
			if AlgorithmsStart = '1' then			
				
				if globals_alg_alg_en = '1' then -- Algorithm globals_alg
					globals_alg_alg_done <= '0';
					
					--logic for resetting algorithm-driven output events
					global_run_changed_eO_alg_out <= '0';
					global_fault_changed_eO_alg_out <= '0';
					
				end if;
				
			end if;

			
			if globals_alg_alg_done = '0' then -- Algorithm globals_alg

--begin algorithm raw text
--update previous values
rx_global_run_prev <= rx_global_run;
rx_global_run_infinite_prev <= rx_global_run_infinite;
rx_global_fault_prev <= rx_global_fault;

--these are what we use to drive events
--global_run_changed_eO_alg_out;
--global_fault_changed_eO_alg_out;

if rx_global_run_prev /= rx_global_run or rx_global_run_infinite_prev /= rx_global_run_infinite then
	global_run_changed_eO_alg_out <= '1';
	global_run <= rx_global_run;
	global_run_infinite <= rx_global_run_infinite;
end if;

if rx_global_fault_prev /= rx_global_fault then
	global_fault_changed_eO_alg_out <= '1';
	global_fault <= rx_global_fault;
end if;

globals_alg_alg_done <= '1';

--end algorithm raw text

			end if;
			
		end if;
	end process;

	--Done signal
	AlgorithmsDone <= (not AlgorithmsStart) and (not enable) and globals_alg_alg_done;
	Done <= AlgorithmsDone;

	
	--logic for renamed output events
	global_run_changed_eO <= global_run_changed_eO_ecc_out or global_run_changed_eO_alg_out;
	global_fault_changed_eO <= global_fault_changed_eO_ecc_out or global_fault_changed_eO_alg_out;
	

end rtl;
