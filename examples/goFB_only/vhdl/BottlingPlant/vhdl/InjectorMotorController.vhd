-- This file has been automatically generated by go-iec61499-vhdl and should not be edited by hand
-- Converter written by Hammond Pearce and available at github.com/kiwih/go-iec61499-vhdl

-- This file represents the Basic Function Block for InjectorMotorController

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;



entity InjectorMotorController is

	port(
		--for clock and reset signal
		clk		: in	std_logic;
		reset	: in	std_logic;
		enable	: in	std_logic;
		sync	: in	std_logic;
		
		--input events
		InjectorArmFinishedMovement : in std_logic;
		EmergencyStopChanged : in std_logic;
		ConveyorStoppedForInject : in std_logic;
		PumpFinished : in std_logic;
		
		
		--output events
		StartPump : out std_logic;
		InjectDone : out std_logic;
		InjectorPositionChanged : out std_logic;
		InjectRunning : out std_logic;
		
		
		--input variables
		EmergencyStop_I : in std_logic; --type was BOOL
		
		
		--output variables
		InjectorPosition_O : out unsigned(7 downto 0); --type was BYTE
		
		
		--for done signal
		done : out std_logic
	);

end entity;


architecture rtl of InjectorMotorController is
	-- Build an enumerated type for the state machine
	type state_type is (STATE_MoveArmUp, STATE_Await_Bottle, STATE_MoveArmDown, STATE_Await_Pumping);

	-- Register to hold the current state
	signal state   : state_type := STATE_MoveArmUp;

	-- signals to store variable sampled on enable 
	signal EmergencyStop : std_logic := '0'; --register for input
	
	-- signals to rename outputs 
	signal InjectorPosition : unsigned(7 downto 0) := (others => '0'); 
	

	-- signals for enabling algorithms	
	signal SetArmDownPosition_alg_en : std_logic := '0'; 
	signal SetArmDownPosition_alg_done : std_logic := '1';
	
	signal SetArmUpPosition_alg_en : std_logic := '0'; 
	signal SetArmUpPosition_alg_done : std_logic := '1';
	
	signal Algorithm1_alg_en : std_logic := '0'; 
	signal Algorithm1_alg_done : std_logic := '1';
	

	-- signal for algorithm completion
	signal AlgorithmsStart : std_logic := '0';
	signal AlgorithmsDone : std_logic;

	
begin
	-- Registers for data variables (only updated on relevant events)
	process (clk)
	begin
		if rising_edge(clk) then
			if sync = '1' then
				
				if EmergencyStopChanged = '1' then
					EmergencyStop <= EmergencyStop_I;
				end if;
				
			end if;
		end if;
	end process;
	
	--output var renaming, no output registers as inputs are stored where they are processed
	InjectorPosition_O <= InjectorPosition;
			
	
	-- Logic to advance to the next state
	process (clk, reset)
	begin
		if reset = '1' then
			state <= STATE_MoveArmUp;
			AlgorithmsStart <= '1';
		elsif (rising_edge(clk)) then
			if AlgorithmsStart = '1' then --algorithms should be triggered only once via this pulse signal
				AlgorithmsStart <= '0';
			elsif enable = '1' then 
				--default values
				state <= state;
				AlgorithmsStart <= '0';

				--next state logic
				if AlgorithmsStart = '0' and AlgorithmsDone = '1' then
					case state is
						when STATE_MoveArmUp =>
							if InjectorArmFinishedMovement = '1' then
								state <= STATE_Await_Bottle;
								AlgorithmsStart <= '1';
							end if;
						when STATE_Await_Bottle =>
							if ConveyorStoppedForInject = '1' then
								state <= STATE_MoveArmDown;
								AlgorithmsStart <= '1';
							end if;
						when STATE_MoveArmDown =>
							if InjectorArmFinishedMovement = '1' then
								state <= STATE_Await_Pumping;
								AlgorithmsStart <= '1';
							end if;
						when STATE_Await_Pumping =>
							if PumpFinished = '1' then
								state <= STATE_MoveArmUp;
								AlgorithmsStart <= '1';
							end if;
						
					end case;
				end if;
			end if;
		end if;
	end process;

	-- Event outputs and internal algorithm triggers depend solely on the current state
	process (state)
	begin
		--default values
		--events
		StartPump <= '0';
		InjectDone <= '0';
		InjectorPositionChanged <= '0';
		InjectRunning <= '0';
		
		--algorithms
		SetArmDownPosition_alg_en <= '0'; 
		SetArmUpPosition_alg_en <= '0'; 
		Algorithm1_alg_en <= '0'; 

		case state is
			when STATE_MoveArmUp =>
				SetArmUpPosition_alg_en <= '1';
				InjectorPositionChanged <= '1';
				
			when STATE_Await_Bottle =>
				InjectDone <= '1';
				
			when STATE_MoveArmDown =>
				SetArmDownPosition_alg_en <= '1';
				InjectorPositionChanged <= '1';
				InjectRunning <= '1';
				
			when STATE_Await_Pumping =>
				StartPump <= '1';
				
			
		end case;
	end process;

	-- Algorithms process
	process(clk)
	begin
		if rising_edge(clk) then
			if AlgorithmsStart = '1' then			
				
				if SetArmDownPosition_alg_en = '1' then -- Algorithm SetArmDownPosition
					SetArmDownPosition_alg_done <= '0';
				end if;
				
				if SetArmUpPosition_alg_en = '1' then -- Algorithm SetArmUpPosition
					SetArmUpPosition_alg_done <= '0';
				end if;
				
				if Algorithm1_alg_en = '1' then -- Algorithm Algorithm1
					Algorithm1_alg_done <= '0';
				end if;
				
			end if;

			
			if SetArmDownPosition_alg_done = '0' then -- Algorithm SetArmDownPosition

--begin algorithm raw text
InjectorPosition <= x"FF";
SetArmDownPosition_alg_done <= '1';
--end algorithm raw text

			end if;
			
			if SetArmUpPosition_alg_done = '0' then -- Algorithm SetArmUpPosition

--begin algorithm raw text
InjectorPosition <= x"00";
SetArmUpPosition_alg_done <= '1';
--end algorithm raw text

			end if;
			
			if Algorithm1_alg_done = '0' then -- Algorithm Algorithm1

--begin algorithm raw text
Algorithm1_alg_done <= '1';
--end algorithm raw text

			end if;
			
		end if;
	end process;

	--Done signal
	AlgorithmsDone <= (not AlgorithmsStart) and SetArmDownPosition_alg_done and SetArmUpPosition_alg_done and Algorithm1_alg_done;
	Done <= AlgorithmsDone;
end rtl;
