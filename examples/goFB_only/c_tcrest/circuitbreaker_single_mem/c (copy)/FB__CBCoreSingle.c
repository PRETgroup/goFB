// This file has been automatically generated by goFB and should not be edited by hand
// Compiler written by Hammond Pearce and available at github.com/kiwih/goFB

// This file represents the implementation of the Composite Function Block for _CBCoreSingle
#include "FB__CBCoreSingle.h"

//When running a composite block, note that you would call the functions in this order (and this is very important)
//_preinit(); 
//_init();
//do {
//	_syncOutputEvents();
//	_syncInputEvents();
//	_syncOutputData();
//	_syncInputData();
//	_run();
//} loop;


/* _CBCoreSingle_preinit() is required to be called to 
 * initialise an instance of _CBCoreSingle. 
 * It sets all I/O values to zero.
 */
int _CBCoreSingle_preinit(_CBCoreSingle_t  *me) {
	

	
	
	//set any input vars with default values
	
	//set any output vars with default values
	
	
	
	
	//if there are fb children (CFBs/Devices/Resources only), call this same function on them
	if(SifbAmmeter_preinit(&me->amm1) != 0) {
		return 1;
	}
	
	if(SifbTimer_preinit(&me->timer1) != 0) {
		return 1;
	}
	
	if(CfbBreakerController_preinit(&me->cb1) != 0) {
		return 1;
	}
	
	if(SifbManagementControls_preinit(&me->hm1) != 0) {
		return 1;
	}
	
	if(SifbIntLed_preinit(&me->led1) != 0) {
		return 1;
	}
	
	if(SifbManagementControls_preinit(&me->hm3) != 0) {
		return 1;
	}
	
	if(SifbIntLed_preinit(&me->led3) != 0) {
		return 1;
	}
	
	if(SifbAmmeter_preinit(&me->amm3) != 0) {
		return 1;
	}
	
	if(CfbBreakerController_preinit(&me->cb3) != 0) {
		return 1;
	}
	
	if(SifbTimer_preinit(&me->timer3) != 0) {
		return 1;
	}
	
	if(SifbManagementControls_preinit(&me->hm2) != 0) {
		return 1;
	}
	
	if(SifbIntLed_preinit(&me->led2) != 0) {
		return 1;
	}
	
	if(SifbAmmeter_preinit(&me->amm2) != 0) {
		return 1;
	}
	
	if(CfbBreakerController_preinit(&me->cb2) != 0) {
		return 1;
	}
	
	if(SifbTimer_preinit(&me->timer2) != 0) {
		return 1;
	}
	
	if(SifbCBPrintStatus_preinit(&me->print) != 0) {
		return 1;
	}
	
	
	

	
	
	

	

	return 0;
}

/* _CBCoreSingle_init() is required to be called to 
 * set up an instance of _CBCoreSingle. 
 * It passes around configuration data.
 */
int _CBCoreSingle_init(_CBCoreSingle_t  *me) {
	//pass in any parameters on this level
	
	
	

	//perform a data copy to all children (if any present) (can move config data around, doesn't do anything otherwise)
	
	
	//sync config for amm1 (of Type SifbAmmeter) 
			//sync config for timer1 (of Type SifbTimer) 
			//sync config for cb1 (of Type CfbBreakerController) 
			me->cb1.i = me->amm1.i;
							me->cb1.i_set = me->hm1.i_set;
							//sync config for hm1 (of Type SifbManagementControls) 
			//sync config for led1 (of Type SifbIntLed) 
			me->led1.i = me->cb1.b;
							//sync config for hm3 (of Type SifbManagementControls) 
			//sync config for led3 (of Type SifbIntLed) 
			me->led3.i = me->cb3.b;
							//sync config for amm3 (of Type SifbAmmeter) 
			//sync config for cb3 (of Type CfbBreakerController) 
			me->cb3.i = me->amm3.i;
							me->cb3.i_set = me->hm3.i_set;
							//sync config for timer3 (of Type SifbTimer) 
			//sync config for hm2 (of Type SifbManagementControls) 
			//sync config for led2 (of Type SifbIntLed) 
			me->led2.i = me->cb2.b;
							//sync config for amm2 (of Type SifbAmmeter) 
			//sync config for cb2 (of Type CfbBreakerController) 
			me->cb2.i = me->amm2.i;
							me->cb2.i_set = me->hm2.i_set;
							//sync config for timer2 (of Type SifbTimer) 
			//sync config for print (of Type SifbCBPrintStatus) 
			me->print.St1 = me->cb1.b;
							me->print.St2 = me->cb2.b;
							me->print.St3 = me->cb3.b;
							

	//if there are fb children (CFBs/Devices/Resources only), call this same function on them
	if(SifbAmmeter_init(&me->amm1) != 0) {
		return 1;
	}
	if(SifbTimer_init(&me->timer1) != 0) {
		return 1;
	}
	if(CfbBreakerController_init(&me->cb1) != 0) {
		return 1;
	}
	if(SifbManagementControls_init(&me->hm1) != 0) {
		return 1;
	}
	if(SifbIntLed_init(&me->led1) != 0) {
		return 1;
	}
	if(SifbManagementControls_init(&me->hm3) != 0) {
		return 1;
	}
	if(SifbIntLed_init(&me->led3) != 0) {
		return 1;
	}
	if(SifbAmmeter_init(&me->amm3) != 0) {
		return 1;
	}
	if(CfbBreakerController_init(&me->cb3) != 0) {
		return 1;
	}
	if(SifbTimer_init(&me->timer3) != 0) {
		return 1;
	}
	if(SifbManagementControls_init(&me->hm2) != 0) {
		return 1;
	}
	if(SifbIntLed_init(&me->led2) != 0) {
		return 1;
	}
	if(SifbAmmeter_init(&me->amm2) != 0) {
		return 1;
	}
	if(CfbBreakerController_init(&me->cb2) != 0) {
		return 1;
	}
	if(SifbTimer_init(&me->timer2) != 0) {
		return 1;
	}
	if(SifbCBPrintStatus_init(&me->print) != 0) {
		return 1;
	}
	
	

	return 0;
}



/* _CBCoreSingle_syncOutputEvents() synchronises the output events of an
 * instance of _CBCoreSingle as required by synchronous semantics.
 * Notice that it does NOT perform any computation - this occurs in the
 * _run function.
 */
void _CBCoreSingle_syncOutputEvents(_CBCoreSingle_t  *me) {
	//first, for all cfb children, call this same function
	
	CfbBreakerController_syncOutputEvents(&me->cb1);//sync for cb1 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncOutputEvents(&me->cb3);//sync for cb3 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncOutputEvents(&me->cb2);//sync for cb2 (of type CfbBreakerController) which is a CFB//then, for all connections that are connected to an output on the parent, run their run their copy
	}

/* _CBCoreSingle_syncInputEvents() synchronises the input events of an
 * instance of _CBCoreSingle as required by synchronous semantics.
 * Notice that it does NOT perform any computation - this occurs in the
 * _run function.
 */
void _CBCoreSingle_syncInputEvents(_CBCoreSingle_t  *me) {
	//first, we explicitly synchronise the children
	
	me->cb1.inputEvents.event.tick = me->timer1.outputEvents.event.Tick; 
	
	me->cb1.inputEvents.event.i_measured = me->amm1.outputEvents.event.i_measured; 
	
	me->cb1.inputEvents.event.i_set_change = me->hm1.outputEvents.event.i_set_change; 
	
	me->cb1.inputEvents.event.brk = me->hm1.outputEvents.event.brk; 
	
	me->cb1.inputEvents.event.rst = me->hm1.outputEvents.event.rst; 
	
	me->led1.inputEvents.event.i_change = me->cb1.outputEvents.event.b_change; 
	
	me->led3.inputEvents.event.i_change = me->cb3.outputEvents.event.b_change; 
	
	me->cb3.inputEvents.event.tick = me->timer3.outputEvents.event.Tick; 
	
	me->cb3.inputEvents.event.i_measured = me->amm3.outputEvents.event.i_measured; 
	
	me->cb3.inputEvents.event.i_set_change = me->hm3.outputEvents.event.i_set_change; 
	
	me->cb3.inputEvents.event.brk = me->hm3.outputEvents.event.brk; 
	
	me->cb3.inputEvents.event.rst = me->hm3.outputEvents.event.rst; 
	
	me->led2.inputEvents.event.i_change = me->cb2.outputEvents.event.b_change; 
	
	me->cb2.inputEvents.event.tick = me->timer2.outputEvents.event.Tick; 
	
	me->cb2.inputEvents.event.i_measured = me->amm2.outputEvents.event.i_measured; 
	
	me->cb2.inputEvents.event.i_set_change = me->hm2.outputEvents.event.i_set_change; 
	
	me->cb2.inputEvents.event.brk = me->hm2.outputEvents.event.brk; 
	
	me->cb2.inputEvents.event.rst = me->hm2.outputEvents.event.rst; 
	
	me->print.inputEvents.event.StatusUpdate = me->cb1.outputEvents.event.b_change || me->cb3.outputEvents.event.b_change || me->cb2.outputEvents.event.b_change; 
	

	//then, call this same function on all cfb children
	
	CfbBreakerController_syncInputEvents(&me->cb1);//sync for cb1 (of type CfbBreakerController) which is a CFB
	
	CfbBreakerController_syncInputEvents(&me->cb3);//sync for cb3 (of type CfbBreakerController) which is a CFB
	
	CfbBreakerController_syncInputEvents(&me->cb2);//sync for cb2 (of type CfbBreakerController) which is a CFB
	
}

/* _CBCoreSingle_syncOutputData() synchronises the output data connections of an
 * instance of _CBCoreSingle as required by synchronous semantics.
 * It does the checking to ensure that only connections which have had their
 * associated event fire are updated.
 * Notice that it does NOT perform any computation - this occurs in the
 * _run function.
 */
void _CBCoreSingle_syncOutputData(_CBCoreSingle_t  *me) {
	//for all composite function block children, call this same function
	//sync for cb1 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncOutputData(&me->cb1);//sync for cb3 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncOutputData(&me->cb3);//sync for cb2 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncOutputData(&me->cb2);
	
	//for data that is sent from child to this CFB (me), always copy (event controlled copies will be resolved at the next level up) //TODO: arrays!?
	
	
}

/* _CBCoreSingle_syncInputData() synchronises the input data connections of an
 * instance of _CBCoreSingle as required by synchronous semantics.
 * It does the checking to ensure that only connections which have had their
 * associated event fire are updated.
 * Notice that it does NOT perform any computation - this occurs in the
 * _run function.
 */
void _CBCoreSingle_syncInputData(_CBCoreSingle_t  *me) {
	//for all basic function block children, perform their synchronisations explicitly
	
	//sync for amm1 (of type SifbAmmeter) which is a BFB
	
	
	//sync for timer1 (of type SifbTimer) which is a BFB
	
	//sync for cb1 (of Type CfbBreakerController) which is a CFB
	
	
		me->cb1.i = me->amm1.i;
	
	
		me->cb1.i_set = me->hm1.i_set;
	
	//sync for hm1 (of type SifbManagementControls) which is a BFB
	
	
	//sync for led1 (of type SifbIntLed) which is a BFB
	
	if(me->led1.inputEvents.event.i_change == 1) {
		me->led1.i = me->cb1.b;
		
	} 
	
	//sync for hm3 (of type SifbManagementControls) which is a BFB
	
	
	//sync for led3 (of type SifbIntLed) which is a BFB
	
	if(me->led3.inputEvents.event.i_change == 1) {
		me->led3.i = me->cb3.b;
		
	} 
	
	//sync for amm3 (of type SifbAmmeter) which is a BFB
	
	//sync for cb3 (of Type CfbBreakerController) which is a CFB
	
	
		me->cb3.i = me->amm3.i;
	
	
		me->cb3.i_set = me->hm3.i_set;
	
	//sync for timer3 (of type SifbTimer) which is a BFB
	
	
	//sync for hm2 (of type SifbManagementControls) which is a BFB
	
	
	//sync for led2 (of type SifbIntLed) which is a BFB
	
	if(me->led2.inputEvents.event.i_change == 1) {
		me->led2.i = me->cb2.b;
		
	} 
	
	//sync for amm2 (of type SifbAmmeter) which is a BFB
	
	//sync for cb2 (of Type CfbBreakerController) which is a CFB
	
	
		me->cb2.i = me->amm2.i;
	
	
		me->cb2.i_set = me->hm2.i_set;
	
	//sync for timer2 (of type SifbTimer) which is a BFB
	
	
	//sync for print (of type SifbCBPrintStatus) which is a BFB
	
	if(me->print.inputEvents.event.StatusUpdate == 1) {
		me->print.St1 = me->cb1.b;
		me->print.St2 = me->cb2.b;
		me->print.St3 = me->cb3.b;
		
	} 
	
	
	//for all composite function block children, call this same function
	//sync for cb1 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncInputData(&me->cb1);//sync for cb3 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncInputData(&me->cb3);//sync for cb2 (of type CfbBreakerController) which is a CFB
	CfbBreakerController_syncInputData(&me->cb2);
	
}


/* _CBCoreSingle_run() executes a single tick of an
 * instance of _CBCoreSingle according to synchronise semantics.
 * Notice that it does NOT perform any I/O - synchronisation
 * is done using the _syncX functions at this (and any higher) level.
 */
void _CBCoreSingle_run(_CBCoreSingle_t  *me) {
	
	
	SifbAmmeter_run(&me->amm1);
	
	SifbTimer_run(&me->timer1);
	
	CfbBreakerController_run(&me->cb1);
	
	SifbManagementControls_run(&me->hm1);
	
	SifbIntLed_run(&me->led1);
	
	SifbManagementControls_run(&me->hm3);
	
	SifbIntLed_run(&me->led3);
	
	SifbAmmeter_run(&me->amm3);
	
	CfbBreakerController_run(&me->cb3);
	
	SifbTimer_run(&me->timer3);
	
	SifbManagementControls_run(&me->hm2);
	
	SifbIntLed_run(&me->led2);
	
	SifbAmmeter_run(&me->amm2);
	
	CfbBreakerController_run(&me->cb2);
	
	SifbTimer_run(&me->timer2);
	
	SifbCBPrintStatus_run(&me->print);
	
}





