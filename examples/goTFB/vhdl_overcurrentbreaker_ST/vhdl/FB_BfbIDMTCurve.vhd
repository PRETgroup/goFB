-- This file has been automatically generated by goFB and should not be edited by hand
-- Compiler written by Hammond Pearce and available at github.com/kiwih/goFB
-- VHDL support is EXPERIMENTAL ONLY

-- This file represents the Basic Function Block for BfbIDMTCurve

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;



entity BfbIDMTCurve is

	port(
		--for clock and reset signal
		clk		: in	std_logic;
		reset	: in	std_logic;
		enable	: in	std_logic;
		sync	: in	std_logic;
		
		--input events
		tick_eI : in std_logic := '0';
		i_measured_eI : in std_logic := '0';
		iSet_change_eI : in std_logic := '0';
		
		
		--output events
		unsafe_eO : out std_logic;
		
		
		--input variables
		i_I : in unsigned(31 downto 0) := (others => '0'); --type was ULINT
		iSet_I : in unsigned(31 downto 0) := (others => '0'); --type was ULINT
		
		
		
		--for done signal
		done : out std_logic
	);

end entity;


architecture rtl of BfbIDMTCurve is
	-- Build an enumerated type for the state machine
	type state_type is (STATE_s_start, STATE_s_wait, STATE_s_count, STATE_s_over);

	-- Register to hold the current state
	signal state   : state_type := STATE_s_start;

	signal tick : std_logic;
	signal i_measured : std_logic;
	signal iSet_change : std_logic;
	

	-- signals to store variable sampled on enable 
	signal i : unsigned(31 downto 0) := (others => '0'); --register for input
	signal iSet : unsigned(31 downto 0) := (others => '0'); --register for input
	
	

	
	--signals to rename output events
	signal unsafe_eO_ecc_out : std_logic := '0'; --used when event driven from ECC (normal FB behaviour)
	signal unsafe_eO_alg_out : std_logic := '0'; --used when event driven from algorithm (normal SIFB behaviour)
	

	-- signals for enabling algorithms	
	signal s_wait_alg0_alg_en : std_logic := '0'; 
	signal s_wait_alg0_alg_done : std_logic := '1';
	
	signal s_count_alg0_alg_en : std_logic := '0'; 
	signal s_count_alg0_alg_done : std_logic := '1';
	
	signal updateThresh_alg_en : std_logic := '0'; 
	signal updateThresh_alg_done : std_logic := '1';
	

	-- signal for algorithm completion
	signal AlgorithmsStart : std_logic := '0';
	signal AlgorithmsDone : std_logic;

	--internal variables 
	signal v : unsigned(63 downto 0); --type was ULINT 
	signal thresh : unsigned(63 downto 0); --type was ULINT 
	signal K : unsigned(31 downto 0) := to_unsigned(10000,32); --type was ULINT 
	signal B : unsigned(31 downto 0) := to_unsigned(135, 32); --type was ULINT 
begin

	tick <= tick_eI;
	i_measured <= i_measured_eI;
	iSet_change <= iSet_change_eI;
	

	-- Registers for data variables (only updated on relevant events)
	process (clk)
	begin
		if rising_edge(clk) then
			if sync = '1' then
				
				if i_measured_eI = '1' then
					i <= i_I;
				end if;
				
				if iSet_change_eI = '1' then
					iSet <= iSet_I;
				end if;
				
			end if;
		end if;
	end process;
	
			
	
	-- Logic to advance to the next state
	process (clk, reset)
	begin
		if reset = '1' then
			state <= STATE_s_start;
			AlgorithmsStart <= '1';
		elsif (rising_edge(clk)) then
			if AlgorithmsStart = '1' then --algorithms should be triggered only once via this pulse signal
				AlgorithmsStart <= '0';
			elsif enable = '1' then 
				--default values
				state <= state;
				AlgorithmsStart <= '0';

				--next state logic
				case state is
					when STATE_s_start =>
						if true then
							state <= STATE_s_wait;
							AlgorithmsStart <= '1';
						end if;
					when STATE_s_wait =>
						if i > iSet then
							state <= STATE_s_count;
							AlgorithmsStart <= '1';
						end if;
					when STATE_s_count =>
						if i <= iSet then
							state <= STATE_s_wait;
							AlgorithmsStart <= '1';
						elsif v > thresh then
							state <= STATE_s_over;
							AlgorithmsStart <= '1';
						elsif tick = '1' then
							state <= STATE_s_count;
							AlgorithmsStart <= '1';
						end if;
					when STATE_s_over =>
						if i <= iSet then
							state <= STATE_s_wait;
							AlgorithmsStart <= '1';
						elsif true then
							state <= STATE_s_over;
							AlgorithmsStart <= '1';
						end if;
					
				end case;

			end if;
		end if;
	end process;

	-- Event outputs and internal algorithm triggers depend solely on the current state
	process (state)
	begin
		--default values
		--events
		unsafe_eO_ecc_out <= '0';
		
		--algorithms
		s_wait_alg0_alg_en <= '0'; 
		s_count_alg0_alg_en <= '0'; 
		updateThresh_alg_en <= '0'; 

		case state is
			when STATE_s_start =>
				
			when STATE_s_wait =>
				s_wait_alg0_alg_en <= '1';
				
			when STATE_s_count =>
				updateThresh_alg_en <= '1';
				s_count_alg0_alg_en <= '1';
				
			when STATE_s_over =>
				unsafe_eO_ecc_out <= '1';
				
			
		end case;
	end process;

	-- Algorithms process
	process(clk)
	begin
		if rising_edge(clk) then
			if AlgorithmsStart = '1' then			
				
				if s_wait_alg0_alg_en = '1' then -- Algorithm s_wait_alg0
					s_wait_alg0_alg_done <= '0';
					
					--logic for resetting algorithm-driven output events
					unsafe_eO_alg_out <= '0';
					
				end if;
				
				if s_count_alg0_alg_en = '1' then -- Algorithm s_count_alg0
					s_count_alg0_alg_done <= '0';
					
					--logic for resetting algorithm-driven output events
					unsafe_eO_alg_out <= '0';
					
				end if;
				
				if updateThresh_alg_en = '1' then -- Algorithm updateThresh
					updateThresh_alg_done <= '0';
					
					--logic for resetting algorithm-driven output events
					unsafe_eO_alg_out <= '0';
					
				end if;
				
			end if;

			
			if s_wait_alg0_alg_done = '0' then -- Algorithm s_wait_alg0

--begin algorithm raw text
v <= to_unsigned(0, 64);
--end algorithm raw text

			end if;
			
			if s_count_alg0_alg_done = '0' then -- Algorithm s_count_alg0

--begin algorithm raw text
v <= v + 1;
--end algorithm raw text

			end if;
			
			if updateThresh_alg_done = '0' then -- Algorithm updateThresh

--begin algorithm raw text

        thresh <= ((K*B) / ((i / iSet) - 1));
    
--end algorithm raw text

			end if;
			
		end if;
	end process;

	--Done signal
	AlgorithmsDone <= (not AlgorithmsStart) and (not enable) and s_wait_alg0_alg_done and s_count_alg0_alg_done and updateThresh_alg_done;
	Done <= AlgorithmsDone;

	
	--logic for renamed output events
	unsafe_eO <= unsafe_eO_ecc_out or unsafe_eO_alg_out;
	

end rtl;
