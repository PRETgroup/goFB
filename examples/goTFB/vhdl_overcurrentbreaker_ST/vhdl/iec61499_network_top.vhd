-- This file has been automatically generated by goFB and should not be edited by hand
-- Compiler written by Hammond Pearce and available at github.com/kiwih/goFB
-- VHDL support is EXPERIMENTAL ONLY

-- This file represents the top level file for the IEC61499 network with CfbOvercurrentDetector as the top level block
-- This is the file that you should embed into your vhdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity iec61499_network_top is

	port(
		--for clock and reset signal
		clk		: in	std_logic;
		reset	: in	std_logic;
		
		
		
		--input events
		tick : in std_logic := '0';
		i_measured : in std_logic := '0';
		test : in std_logic := '0';
		set : in std_logic := '0';
		iSet_change : in std_logic := '0';
		
		
		--output events
		b_change : out std_logic;
		
		
		--input variables
		i : in unsigned(31 downto 0) := (others => '0'); --type was ULINT
		iSet : in unsigned(31 downto 0) := (others => '0'); --type was ULINT
		
		
		--output variables
		b : out std_logic; --type was BOOL
		

		--signals in case external components want to measure time
		debug_enable: out std_logic;
		debug_sync: out std_logic;
		debug_done: out std_logic
	);

end entity;

architecture rtl of iec61499_network_top is
	-- Build an enumerated type for the state machine
	type state_type is (STATE_sync, STATE_wait_sync_done, STATE_run, STATE_wait_run_done);

	-- Register to hold the current state
	signal state   : state_type := STATE_sync;

	signal enable : std_logic := '0';
	signal sync : std_logic := '0';
	signal done : std_logic := '0';
begin

	--port map for top level block
	top_block: entity work.CfbOvercurrentDetector port map(
		clk => clk,
		reset => reset,
		enable => enable,
		sync => sync,
		
		

		
		--input events
		tick_eI => tick,
		i_measured_eI => i_measured,
		test_eI => test,
		set_eI => set,
		iSet_change_eI => iSet_change,
		
		
		--output events
		b_change_eO => b_change,
		
		
		--input variables
		i_I => i,
		iSet_I => iSet,
		
		
		--output variables
		b_O => b,
		

		done => done
	);

	process (clk, reset)
	begin
		if reset = '1' then
			state <= STATE_sync;
		elsif (rising_edge(clk)) then
			--default values
			state <= state;
			enable <= '0';
			sync <= '0';		
			
			case state is
				when STATE_sync =>
					sync <= '1';
					state <= STATE_wait_sync_done;
				when STATE_wait_sync_done => --TODO sync_done signal
					state <= STATE_run;
				when STATE_run =>
					enable <= '1';
					state <= STATE_wait_run_done;
				when STATE_wait_run_done =>
					if done='1' then
						state <= STATE_sync;
					end if;
			end case;	
		end if;
	end process;

	debug_done <= done;
	debug_enable <= enable;
	debug_sync <= sync;

end rtl;
