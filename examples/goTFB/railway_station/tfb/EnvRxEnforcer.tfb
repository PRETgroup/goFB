basicFB EnvRxEnforcer;
interface of EnvRxEnforcer {
	in event SoChange;
    in bool initial false SoGrn with SoChange;

    in event SChange_in;
    in bool initial false SiGrn_in with SChange_in;
    in bool initial false SnGrn_in with SChange_in;
    in bool initial false SsGrn_in with SChange_in;

    in event WChange_in;
    in bool initial false WiDvrg_in with WChange_in;
    in bool initial false WoDvrg_in with WChange_in;
    in bool initial false WnDvrg_in with WChange_in;
    in bool initial false WsDvrg_in with WChange_in;

    in event DChange_in; 
    in bool initial false DwiPrs_in with DChange_in;
    in bool initial false DwoPrs_in with DChange_in;
    in bool initial false DwnPrs_in with DChange_in;
    in bool initial false DwsPrs_in with DChange_in;
    in bool initial false DnPrs_in with DChange_in;
    in bool initial false DsPrs_in with DChange_in;

	out event EnforcerTookAction; //let the controller know it done bad

	out event SChange_out;
    out bool initial false SiGrn_out with SChange_out;
    out bool initial false SnGrn_out with SChange_out;
    out bool initial false SsGrn_out with SChange_out;

    out event WChange_out;
    out bool initial false WiDvrg_out with WChange_out;
    out bool initial false WoDvrg_out with WChange_out;
    out bool initial false WnDvrg_out with WChange_out;
    out bool initial false WsDvrg_out with WChange_out;
}

architecture of EnvRxEnforcer {

	//our own modifiable copies of the inputs
	//we'll make sure we're happy with these before we pass them to the outputs
	internal bool initial false SiGrn, SnGrn, SsGrn, WiDvrg, WoDvrg, WnDvrg, WsDvrg;

	//we have two ways of dealing with failures
	//some failures are recoverable, where we make a change to the inputs and then try another pass
	//some failures are unrecovereable, where we simply don't pass the current i/o to the system
	states {
		idle {
			//do a check through when we get an input event
			run in "C" `printf("idle\r\n");`;
			-> copyVals on (SChange_in || WChange_in);
		}

		copyVals {
			//run in "C" `printf("copyVals\r\n");`;
			run copyInVals;
			-> startCheck;
		}

		startCheck {
			//run in "C" `printf("startCheck\r\n");`;
			-> singleGreenSiSnoSso;
		}

		singleGreenSiSnoSso {
			//run in "C" `printf("singleGreenSiSnoSso\r\n");`;
			-> singleGreenSiSnoSso_unrecoverable on (SiGrn + SnGrn + SsGrn) > 1;
			-> singleGreenSniSsi;
		}

		singleGreenSiSnoSso_unrecoverable {
			//too many greens, no way to rectify this
			//stick with current outputs, take no action other than blocking
			//run in "C" `printf("singleGreenSiSnoSso_unrecoverable\r\n");`;
			emit EnforcerTookAction;
			-> idle;
		}

		singleGreenSniSsi {
			//run in "C" `printf("singleGreenSniSsi\r\n");`;
			-> singleGreenSniSsi_unrecoverable on (SnGrn + SsGrn) > 1;
			-> finished;
		}

		singleGreenSniSsi_unrecoverable {
			//too many greens, no way to rectify
			//run in "C" `printf("singleGreenSniSsi_unrecoverable\r\n");`;
			emit EnforcerTookAction;
			-> idle;
		}

		finished {
			//run in "C" `printf("finished\r\n");`;
			run copyOutVals;
			//it's not super clean to emit the events if we don't *have* to, but nothing will technically be hurt if we do
			emit SChange_out;
			emit WChange_out;
			-> idle;
		}


	}

	algorithm copyInVals in "C" `
		//printf("copying in vals\r\n");
		me->SiGrn = me->SiGrn_in;
		me->SnGrn = me->SnGrn_in;
		me->SsGrn = me->SsGrn_in;

		me->WiDvrg = me->WiDvrg_in;
		me->WoDvrg = me->WoDvrg_in;
		me->WnDvrg = me->WnDvrg_in;
		me->WsDvrg = me->WsDvrg_in;
	`;

	algorithm copyOutVals in "C" `
		//printf("copying out vals\r\n");
		me->SiGrn_out = me->SiGrn;
		me->SnGrn_out = me->SnGrn;
		me->SsGrn_out = me->SsGrn;

		me->WiDvrg_out = me->WiDvrg;
		me->WoDvrg_out = me->WoDvrg;
		me->WnDvrg_out = me->WnDvrg;
		me->WsDvrg_out = me->WsDvrg;
	`;
}