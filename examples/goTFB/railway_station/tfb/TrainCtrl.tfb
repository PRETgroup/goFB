basicFB TrainCtrl;
interface of TrainCtrl {
    in event RiChange;
    in bool initial false RiReq with RiChange;

    in event RnChange;
    in bool initial false RnReq with RnChange;

    in event RsChange;
    in bool initial false RsReq with RsChange;

    in event DwiChange;
    in bool initial false DwiPrs with DwiChange;

    in event DwoChange;
    in bool initial false DwoPrs with DwoChange;

    in event DwnChange;
    in bool initial false DwnPrs with DwnChange;

    in event DwsChange;
    in bool initial false DwsPrs with DwsChange;

    in event DnChange;
    in bool initial false DnPrs with DnChange;

    in event DsChange;
    in bool initial false DsPrs with DsChange;

    out event SChange;
    out bool initial false SiGrn with SChange;
    out bool initial false SoGrn with SChange;
    out bool initial false SniGrn with SChange;
    out bool initial false SnoGrn with SChange;
    out bool initial false SsiGrn with SChange;
    out bool initial false SsoGrn with SChange;

    out event WChange;
    out bool initial false WiDvrg with WChange;
    out bool initial false WoDvrg with WChange;
    out bool initial false WnDvrg with WChange;
    out bool initial false WsDvrg with WChange;
}

architecture of TrainCtrl {
    state init {
        -> idle;
    }

    //in the idle state, all signals should be RED
    //switch positions don't really matter
    state idle {
        run ClrSignals;
        emit SChange;

        -> n_allow_train_exit_0 on RnChange and RnReq == true;
        -> s_allow_train_exit_0 on RsChange and RsReq == true;
        -> i_allow_train_entrance_0 on RiChange && RiReq == true;
    }

    //here's the algorithms that manage the signal/switch network
    algorithm ClrSignals in "C" `
        me->SiGrn = false;
        me->SoGrn = false;
        me->SniGrn = false;
        me->SnoGrn = false;
        me->SsiGrn = false;
        me->SsoGrn = false;
    `;

    algorithm SetNEntrance in "C" `
        me->SiGrn = true;
        me->WiDvrg = false;
        me->WnDvrg = false;
        me->SniGrn = true;
    `;

    algorithm SetSEntrance in "C" `
        me->SiGrn = true;
        me->WiDvrg = true;
        me->WsDvrg = true;
        me->SsiGrn = true;
    `;

    algorithm SetNExit in "C" `
        me->SnoGrn = true;
        me->WnDvrg = true;
        me->WoDvrg = true;
        me->SoGrn = true;
    `;

    algorithm SetNExitHalf in "C" `
        me->SnoGrn = false;
    `;

    algorithm SetSExit in "C" `
        me->SsoGrn = true;
        me->WsDvrg = false;
        me->WoDvrg = false;
        me->SoGrn = true;
    `;

    algorithm SetSExitHalf in "C" `
        me->SsoGrn = false;
    `;

    //train EXITS from platform N
    states {
        n_allow_train_exit_0 {
            run SetNExit;
            emit SChange;
            emit WChange;

            -> n_allow_train_exit_passed_first_signal on DwnChange and DwnPrs == false;
        }

        n_allow_train_exit_passed_first_signal {
            run SetNExitHalf;
            emit SChange; 

            -> idle on DwoChange and DwoPrs == false;
        }
    }

    //train EXITS from platform S 
    states {
        s_allow_train_exit_0 {
            run SetSExit;
            emit SChange;
            emit WChange;

            -> s_allow_train_exit_passed_first_signal on DwsChange and DwsPrs == false;
        }

        s_allow_train_exit_passed_first_signal {
            run SetSExitHalf;
            emit SChange; 

            -> idle on DwoChange and DwoPrs == false;
        }
    }

    //train ENTRANCE to platform
    states {
        i_allow_train_entrance_0 {
            //decide which platform to go to
            run in "C" `printf("not yet implemented!\r\n"); while(1);`;
        }
    }


}