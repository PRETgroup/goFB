// This file has been automatically generated by go-iec61499 and should not be edited by hand
// Converter written by Hammond Pearce and available at github.com/kiwih/go-iec61499

// This file represents the implementation of the Composite Function Block for FlexPRET
#include "FlexPRET.h"

/* FlexPRET_init() is required to be called to 
 * initialise an instance of FlexPRET. 
 * As this is a composite function block, it contains no values of its own,
 * and so merely calls the initialisation routines of its children.
 */
void FlexPRET_init(struct FlexPRET *me) {
	IOManager_init(&me->IO);
	CanisterCounter_init(&me->CCounter);
	DoorController_init(&me->Door);
	ConveyorController_init(&me->Conveyor);
	RejectArmController_init(&me->RejectArm);
	InjectorPumpsController_init(&me->Pumps);
	InjectorMotorController_init(&me->Motor);
	
}

/* FlexPRET_sync() synchronises an
 * instance of FlexPRET according to synchronise semantics.
 * Notice that it does NOT perform any computation - additional steps
 * will need to be done at the parent.
 */
void FlexPRET_sync(struct FlexPRET *me) {
	//for all composite function block children, call this same function
	//for all basic function block children, perform their synchronisations explicitly
	
	//sync for IO (of type IOManager) which is a BFB
	me->IO.InputEvents.event.DoorReleaseCanister = ?;
	me->IO.InputEvents.event.ConveyorChanged = ?;
	me->IO.InputEvents.event.InjectorPositionChanged = ?;
	me->IO.InputEvents.event.InjectorControlsChanged = ?;
	me->IO.InputEvents.event.FillContentsChanged = ?;
	me->IO.InputEvents.event.StartVacuumTimer = ?;
	me->IO.InputEvents.event.GoRejectArm = ?;
	me->IO.InputEvents.event.CanisterCountChanged = ?;
	me->IO.InputEvents.event.InjectDone = ?;
	
	//sync for CCounter (of type CanisterCounter) which is a BFB
	me->CCounter.InputEvents.event.LasersChanged = ?;
	
	//sync for Door (of type DoorController) which is a BFB
	me->Door.InputEvents.event.ReleaseDoorOverride = ?;
	me->Door.InputEvents.event.BottlingDone = ?;
	me->Door.InputEvents.event.EmergencyStopChanged = ?;
	
	//sync for Conveyor (of type ConveyorController) which is a BFB
	me->Conveyor.InputEvents.event.InjectDone = ?;
	me->Conveyor.InputEvents.event.EmergencyStopChanged = ?;
	me->Conveyor.InputEvents.event.LasersChanged = ?;
	
	//sync for RejectArm (of type RejectArmController) which is a BFB
	me->RejectArm.InputEvents.event.RejectCanister = ?;
	me->RejectArm.InputEvents.event.LasersChanged = ?;
	
	//sync for Pumps (of type InjectorPumpsController) which is a BFB
	me->Pumps.InputEvents.event.StartPump = ?;
	me->Pumps.InputEvents.event.EmergencyStopChanged = ?;
	me->Pumps.InputEvents.event.CanisterPressureChanged = ?;
	me->Pumps.InputEvents.event.FillContentsAvailableChanged = ?;
	me->Pumps.InputEvents.event.VacuumTimerElapsed = ?;
	
	//sync for Motor (of type InjectorMotorController) which is a BFB
	me->Motor.InputEvents.event.InjectorArmFinishedMovement = ?;
	me->Motor.InputEvents.event.EmergencyStopChanged = ?;
	me->Motor.InputEvents.event.ConveyorStoppedForInject = ?;
	me->Motor.InputEvents.event.PumpFinished = ?;
	
}


/* FlexPRET_run() executes a single tick of an
 * instance of FlexPRET according to synchronise semantics.
 * Notice that it does NOT perform any I/O - additional synchronisation
 * will need to be done at the parent.
 */
void FlexPRET_run(struct FlexPRET *me) {
	IOManager_run(&me->IO);
	CanisterCounter_run(&me->CCounter);
	DoorController_run(&me->Door);
	ConveyorController_run(&me->Conveyor);
	RejectArmController_run(&me->RejectArm);
	InjectorPumpsController_run(&me->Pumps);
	InjectorMotorController_run(&me->Motor);
	
}

