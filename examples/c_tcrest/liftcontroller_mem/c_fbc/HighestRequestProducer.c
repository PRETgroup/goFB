// This file is generated by FBC.

#include "HighestRequestProducer.h"
#include <string.h>
#include <stdio.h>

/* Function block initialization function */
void HighestRequestProducerinit(HighestRequestProducer* me)
{
    me->_state = 0;
    me->_entered = false;
    me->_input.events = 0;
    me->_output.events = 0;
}

/* ECC algorithms */
void HighestRequestProducer_ResolvePriorityUp(HighestRequestProducer* me)
{
int bitmask;
int PendingReq = 0;
int i = 0;
me->CurrentPriorityValue = -1;
for (i = 0; i < 4; ++i) {
    PendingReq |= me->PendingReqValue[i] << i;
}
printf("Pending Request, direction, current: %d 1 %d\n", PendingReq, me->FloorSensorValue);
// initial condition => priority hasn't been changed
me->CurrentPriorityValue = -1;
bitmask = 0x01;
for (i = 0 ; i < 4; ++i) {
    if (i > me->FloorSensorValue && (PendingReq & bitmask)) {
        me->CurrentPriorityValue = i;
        printf("Up Priority = %d\n", me->CurrentPriorityValue );
        break;
    }
    bitmask = bitmask << 1;
}

}

void HighestRequestProducer_ResolvePriorityDown(HighestRequestProducer* me)
{
int bitmask;
int PendingReq = 0;
int i = 0;
me->CurrentPriorityValue = -1;
for (i = 0; i < 4; ++i) {
    PendingReq |= me->PendingReqValue[i] << i;
}
printf("Pending Request, direction, current: %d 2 %d\n", PendingReq, me->FloorSensorValue);
bitmask = 0x08;
for (i = 4 - 1; i > -1; --i) {
    if (i < me->FloorSensorValue && (PendingReq & bitmask)) {
        me->CurrentPriorityValue  = i;
        printf("Down Priority = %d\n", me->CurrentPriorityValue );
        break;
    }
    bitmask = bitmask >> 1;
}
    
}

void HighestRequestProducer_ResolvePriorityIdle(HighestRequestProducer* me)
{
int bitmask;
int PendingReq = 0;
int i = 0;
me->CurrentPriorityValue = -1;
for (i = 0; i < 4; ++i) {
    PendingReq |= me->PendingReqValue[i] << i;
}
printf("Pending Request, direction, current: %d 3 %d\n", PendingReq, me->FloorSensorValue);
printf("Current %d \n", me->FloorSensorValue);
if (me->FloorSensorValue == 0) {
    printf("Idle case when on bottom floor\n");
    bitmask = 0x01;
    for (i = 0; i < 4; ++i) {
        if (i > me->FloorSensorValue && (PendingReq & bitmask)) {
            me->CurrentPriorityValue = i;
            printf("Init Up Priority = %d\n", me->CurrentPriorityValue);
            break;
        }
        bitmask = bitmask << 1;
    }
} else if (me->FloorSensorValue == 4 - 1) {
    printf("Idle case when on top floor\n");
    bitmask = 0x08;
    for (i = 4 - 1; i > -1; --i) {
        if (i < me->FloorSensorValue && (PendingReq & bitmask)) {
            me->CurrentPriorityValue = i;
            printf("Init Down Priority= %d\n", me->CurrentPriorityValue);
            break;
        }
        bitmask = bitmask >> 1;
    }
} else {
    //if lift is somewhere in the middle it will go down if
    //there is any requests below the current floor
    printf("Idle case when on some middle floor\n");
    bitmask = 0x01;
    for (i = 0; i < 4; ++i) {
        if (i > me->FloorSensorValue && (PendingReq & bitmask)) {
            me->CurrentPriorityValue = i;
            printf("Middle Up Priority = %d\n", me->CurrentPriorityValue);
            break;
        }
        bitmask = bitmask << 1;
    }
    // if there are no up requests > current
    if (me->CurrentPriorityValue == -1) {
        bitmask = 0x08;
        for(i = 4- 1; i > -1; --i) {
            if (i < me->FloorSensorValue && (PendingReq & bitmask)) {
                me->CurrentPriorityValue = i;
                printf("Middle Down Priority = %d\n", me->CurrentPriorityValue);
                break;
            }
            bitmask = bitmask >> 1;
        }
    }
}
}

/* Function block execution function */
void HighestRequestProducerrun(HighestRequestProducer* me)
{
    me->_output.events = 0;

    if (me->_input.events) {
        if (me->_input.event.FloorSensor) {
            me->FloorSensorValue = me->_FloorSensorValue;
        }
        if (me->_input.event.PendingReq) {
            {
                int i;
                for (i = 0; i < 4; i++) {
                    me->PendingReqValue[i] = me->_PendingReqValue[i];
                }
            }
        }
    }
    for (;;) {
        switch (me->_state) {
            case 0:
                // State: Start
                if (!me->_entered) {
                    me->_entered = true;
                }
                else {
                    if (me->_input.event.MotorDirectionUp && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 1;
                        me->_entered = false;
                        continue;
                    }
                    else if (me->_input.event.MotorDirectionDown && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 3;
                        me->_entered = false;
                        continue;
                    }
                    else if (me->_input.event.MotorDirectionIdle && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 2;
                        me->_entered = false;
                        continue;
                    }
                }
                break;
            case 1:
                // State: DirectionUp
                if (!me->_entered) {
                    HighestRequestProducer_ResolvePriorityUp(me);
                    me->_output.event.CurrentPriority = 1;
                    me->_entered = true;
                }
                else {
                    if (me->_input.event.MotorDirectionIdle && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 2;
                        me->_entered = false;
                        continue;
                    }
                    else if (me->_input.event.MotorDirectionDown && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 3;
                        me->_entered = false;
                        continue;
                    }
                    else {
                        me->_state = 0;
                        me->_entered = false;
                        continue;
                    }
                }
                break;
            case 2:
                // State: DirectionIdle
                if (!me->_entered) {
                    HighestRequestProducer_ResolvePriorityIdle(me);
                    me->_output.event.CurrentPriority = 1;
                    me->_entered = true;
                }
                else {
                    if (me->_input.event.MotorDirectionUp && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 1;
                        me->_entered = false;
                        continue;
                    }
                    else if (me->_input.event.MotorDirectionDown && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 3;
                        me->_entered = false;
                        continue;
                    }
                    else {
                        me->_state = 0;
                        me->_entered = false;
                        continue;
                    }
                }
                break;
            case 3:
                // State: DirectionDown
                if (!me->_entered) {
                    HighestRequestProducer_ResolvePriorityDown(me);
                    me->_output.event.CurrentPriority = 1;
                    me->_entered = true;
                }
                else {
                    if (me->_input.event.MotorDirectionUp && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 1;
                        me->_entered = false;
                        continue;
                    }
                    else if (me->_input.event.MotorDirectionIdle && me->_input.event.FloorSensor && me->_input.event.PendingReq) {
                        me->_state = 2;
                        me->_entered = false;
                        continue;
                    }
                    else {
                        me->_state = 0;
                        me->_entered = false;
                        continue;
                    }
                }
                break;
        }
        break;
    }
    if (me->_output.event.CurrentPriority) {
        me->_CurrentPriorityValue = me->CurrentPriorityValue;
    }

    me->_input.events = 0;
}

