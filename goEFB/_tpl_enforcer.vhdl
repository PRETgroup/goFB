{{define "enforcer"}}
--This is an autogenerated file
--Do not modify it by hand
--Generated at {{curdatetime}}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.enforcement_types_{{underscoreString .E.Name}}.all;
{{$enforcerPair := pair .E .PolIndex}}{{$policy := index .E.Policies .PolIndex}}{{$io := policyIO .E .PolIndex}}{{$enforcer := .E}}{{$polIndex := .PolIndex}}
entity enforcer_{{underscoreString .E.Name}}_{{underscoreString $policy.Name}} is
    port
    (
        clk         : in std_logic;
        reset       : in std_logic;
        t           : in unsigned(63 downto 0); --current time in nanoseconds
        e           : out std_logic;            --if enforcement occured

        --the input signals
        {{range $inpIndex, $inp := $io.Inputs}}{{underscoreString $inp.Name}} : {{$inp.Type}} := {{$inp.Initial}};
        {{end}}
        --the enforce signals
        q           : in enforced_signals_{{underscoreString .E.Name}};
        q_prime     : out enforced_signals_{{underscoreString .E.Name}}
    );
end entity;

architecture behaviour of enforcer_{{underscoreString .E.Name}}_{{underscoreString $policy.Name}} is
    {{range $tmrInd, $tmr := $policy.Triggers}}signal trigger_{{$tmr.Name}} : std_logic := '0';
    signal trigger_{{$tmr.Name}}_time : unsigned(63 downto 0) := (others => '0');
    {{end}}
begin
    
    --trigger process
    process(reset, clk, q, t)
    variable q_enf: enforced_signals_{{underscoreString .E.Name}};
    
    begin
        if(rising_edge(clk)) then
            --default values
            
            q_enf := q;
            e <= '0';

            --policies begin
            {{range $reqInd, $req := $policy.Requirements}}
            if({{if $req.With}}{{range $reqWithInd, $reqWith := $req.With}}{{if $reqWithInd}}and {{end}}(trigger_{{$reqWith}} = '1') {{end}}and {{end}}{{range $reqreqInd, $reqreq := $req.Requires}}{{if $reqreqInd}}and {{end}}{{notOpString $enforcer $polIndex $reqreq}} {{end}}) then
                e <= '1';
                --recover
                {{range $recInd, $rec := $req.Recover}}{{opString $enforcer $polIndex $rec}};
                {{end}}
            end if;
            {{end}}

            --Triggers begin (triggers are after policies because a policy might edit a value that a trigger depends on)
            {{range $tmrInd, $tmr := $policy.Triggers}}
            if(trigger_{{$tmr.Name}} = '0' and ({{opString $enforcer $polIndex $tmr.StartCondition}})) then
                trigger_{{$tmr.Name}} <= '1';
                trigger_{{$tmr.Name}}_time <= t;
            end if;
            {{if $tmr.ResetCondition}}if(trigger_{{$tmr.Name}} = '1' and ({{opString $enforcer $polIndex $tmr.ResetCondition}})) then
                trigger_{{$tmr.Name}} <= '0';
            end if;
            {{end}}{{end}}
            
            q_prime <= q_enf;
        end if;
    end process;


end architecture;
{{end}}

{{/*-- the weird .First etc notation is because of the "pair" and "quad" functions which join arguments together :)-- */}}
{{/*-- yay for run-time empty interfaces in templates!--*/}}
{{define "_operationTpl"}}{{$enforcerPair := .First}}{{$operation := .Second}}{{$isBefore := .Third}}{{$set := .Forth}}{{if $operation.IsValue}}{{$operation.Value}}{{else if $operation.IsVariable}}{{$qtype := classifyVar $enforcerPair.First $enforcerPair.Second $operation.Value}}{{if eq $qtype 2}}{{if $set}}q_enf.{{else}}q_enf.{{end}}{{else if eq $qtype 3}}Trigger_{{end}}{{$operation.Value}}{{else if $operation.IsAfter}}(t {{if $isBefore}}>{{else}}<{{end}} {{template "_operationTpl" quad $enforcerPair $operation.A $isBefore $operation.IsSet}} + {{template "_operationTpl" quad $enforcerPair $operation.B $isBefore $operation.IsSet}}){{else}}{{if not $operation.IsSet}}({{end}}{{template "_operationTpl" quad $enforcerPair $operation.A $isBefore $operation.IsSet}} {{$operation.Type}} {{template "_operationTpl" quad $enforcerPair $operation.B $isBefore $operation.IsSet}}{{if not $operation.IsSet}}){{end}}{{end}}{{end}}