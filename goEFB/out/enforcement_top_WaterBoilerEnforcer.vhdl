
--This is an autogenerated file
--Do not modify it by hand
--Generated at 2017-12-14T16:53:23+13:00
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.enforcement_types_WaterBoilerEnforcer.all;

entity enforcement_top_WaterBoilerEnforcer is
    port
    (
        clk         : in std_logic;
		reset       : in std_logic;

        
		Pboiler_i : in  unsigned(7 downto 0);
		Pboiler_o : out unsigned(7 downto 0);
		
		Fin_i : in  unsigned(7 downto 0);
		Fin_o : out unsigned(7 downto 0);
		
		Fout_i : in  unsigned(7 downto 0);
		Fout_o : out unsigned(7 downto 0);
		
		Fop_i : in  unsigned(7 downto 0);
		Fop_o : out unsigned(7 downto 0);
		
		Lboiler_i : in  unsigned(7 downto 0);
		Lboiler_o : out unsigned(7 downto 0);
		
		Hboiler_i : in  std_logic;
		Hboiler_o : out std_logic;
		
		Cin_i : in  std_logic;
		Cin_o : out std_logic;
		
		Vin_i : in  unsigned(7 downto 0);
		Vin_o : out unsigned(7 downto 0);
		
		Vop_i : in  unsigned(7 downto 0);
		Vop_o : out unsigned(7 downto 0);
		
		Vout_i : in  unsigned(7 downto 0);
		Vout_o : out unsigned(7 downto 0);
		
		Aop_i : in  std_logic;
		Aop_o : out std_logic;
		

		e : out std_logic_vector(1 downto 0)
    );
end entity;

architecture behaviour of enforcement_top_WaterBoilerEnforcer is
    signal ns_time : unsigned(63 downto 0);
	signal enfI, enf0_1, enfO : enforced_signals_WaterBoilerEnforcer;
begin
    
	--this is our global nanosecond timer which counts time since inception
	--64 refers to the number of bits in the counter
	--20 refers to the number the counter will be incremented each tick (for a 50MHz clock, we will have 20ns per tick)
	--a 64-bit nanosecond timer will be able to count for 584.554531 years before overflowing
	count: entity work.binary_counter generic map(
		N => 64,
		I => 20	
	) port map (
		clk		  => clk,
		reset	  	  => '0',
		enable	  => '1',
		q		  	  => ns_time
	); 

	--connect the IO
	
	enfI.Pboiler <= Pboiler_i;
	Pboiler_o <= enfO.Pboiler;
	
	enfI.Fin <= Fin_i;
	Fin_o <= enfO.Fin;
	
	enfI.Fout <= Fout_i;
	Fout_o <= enfO.Fout;
	
	enfI.Fop <= Fop_i;
	Fop_o <= enfO.Fop;
	
	enfI.Lboiler <= Lboiler_i;
	Lboiler_o <= enfO.Lboiler;
	
	enfI.Hboiler <= Hboiler_i;
	Hboiler_o <= enfO.Hboiler;
	
	enfI.Cin <= Cin_i;
	Cin_o <= enfO.Cin;
	
	enfI.Vin <= Vin_i;
	Vin_o <= enfO.Vin;
	
	enfI.Vop <= Vop_i;
	Vop_o <= enfO.Vop;
	
	enfI.Vout <= Vout_i;
	Vout_o <= enfO.Vout;
	
	enfI.Aop <= Aop_i;
	Aop_o <= enfO.Aop;
	

	--policies
	
	enf0 : entity work.enforcer_WaterBoilerEnforcer_P1 port map (
		clk 	=> clk,
		reset 	=> reset,
		t 		=> ns_time,
		e 		=> e(0),
		q 		=> enfI,
		q_prime => enf0_1
	);
	
	enf1 : entity work.enforcer_WaterBoilerEnforcer_P2 port map (
		clk 	=> clk,
		reset 	=> reset,
		t 		=> ns_time,
		e 		=> e(1),
		q 		=> enf0_1,
		q_prime => enfO
	);
	
end architecture;


