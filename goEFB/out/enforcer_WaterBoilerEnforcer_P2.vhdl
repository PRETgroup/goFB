
--This is an autogenerated file
--Do not modify it by hand
--Generated at 2017-12-14T16:53:23+13:00
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.enforcement_types_WaterBoilerEnforcer.all;

entity enforcer_WaterBoilerEnforcer_P2 is
    port
    (
        clk         : in std_logic;
        reset       : in std_logic;
        t           : in unsigned(63 downto 0); --current time in nanoseconds
        e           : out std_logic;            --if enforcement occured

        --the input signals
        
        --the enforce signals
        q           : in enforced_signals_WaterBoilerEnforcer;
        q_prime     : out enforced_signals_WaterBoilerEnforcer
    );
end entity;

architecture behaviour of enforcer_WaterBoilerEnforcer_P2 is
    signal trigger_Top : std_logic := '0';
    signal trigger_Top_time : unsigned(63 downto 0) := (others => '0');
    
begin
    
    --trigger process
    process(reset, clk, q, t)
    variable q_enf: enforced_signals_WaterBoilerEnforcer;
    
    begin
        if(rising_edge(clk)) then
            --default values
            
            q_enf := q;
            e <= '0';

            --policies begin
            
            if((trigger_Top = '1') and (q_enf.Aop = '1') ) then
                e <= '1';
                --recover
                q_enf.Aop := '1';
                
            end if;
            

            --Triggers begin (triggers are after policies because a policy might edit a value that a trigger depends on)
            
            if(trigger_Top = '0' and ((q_enf.Pboiler >= to_unsigned(100, 8)))) then
                trigger_Top <= '1';
                trigger_Top_time <= t;
            end if;
            
            
            q_prime <= q_enf;
        end if;
    end process;


end architecture;
