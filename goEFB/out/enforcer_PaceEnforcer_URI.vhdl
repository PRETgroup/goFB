
--This is an autogenerated file
--Do not modify it by hand
--Generated at 2017-12-08T14:22:41+13:00
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.enforcement_types_PaceEnforcer.all;

entity enforcer_PaceEnforcer_URI is
    port
    (
        clk         : in std_logic;
        reset       : in std_logic;
        t           : in unsigned(63 downto 0); --current time in nanoseconds
        e           : out std_logic;            --if enforcement occured

        --the input signals
        URI_time : unsigned(63 downto 0) := to_unsigned(1000000000, 64);
        
        --the enforce signals
        q           : in enforced_signals_PaceEnforcer;
        q_prime     : out enforced_signals_PaceEnforcer
    );
end entity;

architecture behaviour of enforcer_PaceEnforcer_URI is
    signal trigger_tURI : std_logic := '0';
    signal trigger_tURI_time : unsigned(63 downto 0) := (others => '0');
    
begin
    
    --trigger process
    process(reset, clk, q, t)
    variable q_enf: enforced_signals_PaceEnforcer;
    
    begin
        if(rising_edge(clk)) then
            --default values
            
            q_enf := q;
            e <= '0';

            --policies begin
            
            if((trigger_tURI = '1') and not((q_enf.VP = '0')) and (t < (URI_time + trigger_tURI_time)) ) then
                e <= '1';
                --recover
                q_enf.VP := '0';
                
            end if;
            

            --Triggers begin (triggers are after policies because a policy might edit a value that a trigger depends on)
            
            if(trigger_tURI = '0' and (((q_enf.VS or q_enf.VP) = '1'))) then
                trigger_tURI <= '1';
                trigger_tURI_time <= t;
            end if;
            if(trigger_tURI = '1' and ((t > (URI_time + trigger_tURI_time)))) then
                trigger_tURI <= '0';
            end if;
            
            
            q_prime <= q_enf;
        end if;
    end process;


end architecture;
