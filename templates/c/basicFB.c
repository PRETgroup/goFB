{{define "basicFB"}}// This file has been automatically generated by go-iec61499 and should not be edited by hand
// Converter written by Hammond Pearce and available at github.com/kiwih/go-iec61499
{{$block := index .Blocks .BlockIndex}}{{$blocks := .Blocks}}{{$basicFB := $block.BasicFB}}
// This file represents the implementation of the Basic Function Block for {{$block.Name}}
#include "{{$block.Name}}.h"

enum {{$block.Name}}_states { {{range $index, $state := $basicFB.States}}{{if $index}}, {{end}}STATE_{{$state.Name}}{{end}} };

/* {{$block.Name}}_init() is required to be called to 
 * initialise an instance of {{$block.Name}}. 
 * It sets all I/O values to zero.
 */
void {{$block.Name}}_init(struct {{$block.Name}} *me) {
	//if there are input events, reset them
	{{if $block.EventInputs}}{{range $index, $count := count (add (div (len $block.EventInputs.Events) 32) 1)}}me->inputEvents.events[{{$count}}] = 0;
	{{end}}{{end}}
	//if there are output events, reset them
	{{if $block.EventOutputs}}{{range $index, $count := count (add (div (len $block.EventOutputs.Events) 32) 1)}}me->outputEvents.events[{{$count}}] = 0;
	{{end}}{{end}}
	//if there are input vars, reset them
	{{if $block.InputVars}}{{range $index, $var := $block.InputVars.Variables}}me->{{$var.Name}} = 0;
	{{end}}{{end}}
	//if there are output vars, reset them
	{{if $block.OutputVars}}{{range $index, $var := $block.OutputVars.Variables}}me->{{$var.Name}} = 0;
	{{end}}{{end}}
	//if there are internal vars, reset them
	{{if $block.BasicFB.InternalVars}}{{range $varIndex, $var := $block.BasicFB.InternalVars.Variables}}me->{{$var.Name}} = 0;
	{{end}}{{end}}
}

/* {{$block.Name}}_run() executes a single tick of an
 * instance of {{$block.Name}} according to synchronous semantics.
 * Notice that it does NOT perform any I/O - synchronisation
 * will need to be done in the parent.
 */
void {{$block.Name}}_run(struct {{$block.Name}} *me) {
	//current state storage
	static enum {{$block.Name}}_states state = STATE_{{(index $basicFB.States 0).Name}};
	static BOOL trigger = false;

	//if there are output events, reset them
	{{if $block.EventOutputs}}{{range $index, $count := count (add (div (len $block.EventOutputs.Events) 32) 1)}}me->outputEvents.events[{{$count}}] = 0;
	{{end}}{{end}}
	//now, let's advance state
	switch(state) {
	{{range $curStateIndex, $curState := $basicFB.States}}case STATE_{{$curState.Name}}:
		{{range $transIndex, $trans := $basicFB.GetTransitionsForState $curState.Name}}{{if $transIndex}}} else {{end}}if({{getCECCTransitionCondition $block $trans.Condition}}) {
			state = STATE_{{$trans.Destination}};
			trigger = true;
		{{end}}};
		break;

	{{end}}
	}

	//now, let's run any algorithms and emit any events that need to occur due to the trigger
	if(trigger == true) {
		switch(state) {
		{{range $curStateIndex, $curState := $basicFB.States}}case STATE_{{$curState.Name}}:
			{{range $actionIndex, $action := $curState.ECActions}}{{if $action.Algorithm}}{{$block.Name}}_{{$action.Algorithm}}(me);
			{{end}}{{if $action.Output}}me->outputEvents.event.{{$action.Output}} = 1;
			{{end}}{{end}}break;

		{{end}}
		}
	}
}

{{if $basicFB.Algorithms}}//algorithms
{{range $algIndex, $alg := $basicFB.Algorithms}}
void {{$block.Name}}_{{$alg.Name}}(struct {{$block.Name}} *me) {
{{$alg.Other.Text}}
}
{{end}}
{{else}}//no algorithms were present for this function block
{{end}}

{{end}}