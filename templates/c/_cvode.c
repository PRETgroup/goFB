{{define "_cvode_fs"}}{{$basicFB := .BasicFB}}{{$block := .}}

{{range $algIndex, $alg := $basicFB.Algorithms}}
{{if algorithmNeedsCvode $alg}}
static int {{$block.Name}}_{{$alg.Name}}_f(realtype t, N_Vector ode_solution, N_Vector ode_solution_dot, void *f_data) {
	//AUTOGENERATED CODE: this function represents the ODE in {{$block.Name}}'s {{$alg.Name}} algorithm
	//it is in a format that CVODE can process.
	{{$block.Name}}_t *me = ({{$block.Name}}_t*)f_data;
	{{$odeTick := parseOdeRunAlgo .Other.Text}}{{range $varIndex, $var := $odeTick.Vars}}
	NV_Ith_S(ode_solution_dot, {{$varIndex}}) = {{$trans := getCECCTransitionCondition $block $var.VarValue}}{{$trans.IfCond}};
	{{end}}
	return 0;
}

void {{$block.Name}}_{{$alg.Name}}_f_tick({{$block.Name}}_t *me) {
	//AUTOGENERATED CODE: this function manages iterations of the ODE in {{$block.Name}}'s {{$alg.Name}} algorithm
	//It calls the CVODE solver and sets the outputs of the HA FB.
	me->Tnext += me->delta;
	int flag = CVode(me->cvode_mem, me->Tnext, me->ode_solution, &me->Tcurr, CV_NORMAL);
	if (flag < 0) {
		fprintf(stderr, "Error in CVode: %d\n", flag);
		while(1);
	}
	{{$odeTick := parseOdeRunAlgo .Other.Text}}{{range $varIndex, $var := $odeTick.Vars}}
	me->{{$var.VarName}} = NV_Ith_S(me->ode_solution, {{$varIndex}});
	{{end}}
}

{{else if algorithmNeedsCvodeInit $alg}}
void {{$block.Name}}_{{$alg.Name}}_cvode_init({{$block.Name}}_t *me) {
	//AUTOGENERATED CODE: this algorithm specifies the initialization of a CVODE SUNDIALS solver and was parsed from the algorithm's text field
	int flag;
	{{$odeInit := parseOdeInitAlgo .Other.Text}}
	//specify tolerances
	realtype reltol = 1e-6;
    realtype abstol = 1e-8;

	//free solver if it is initialized
	if(me->cvode_mem != NULL) {
		CVodeFree(&me->cvode_mem);
		N_VDestroy_Serial(me->ode_solution);  /* Free y vector */
	}

	//create solver
	me->ode_solution = N_VNew_Serial({{len $odeInit.GetInitialValues}}); //length of initial values
	me->cvode_mem = CVodeCreate(CV_ADAMS, CV_FUNCTIONAL);
	if (me->cvode_mem == 0) {
		fprintf(stderr, "Error in CVodeMalloc: could not allocate\n");
		while(1);
	}

	//specify initial values
	{{range $initVarIndex, $initVar := $odeInit.GetInitialValues}}
	NV_Ith_S(me->ode_solution, {{$initVarIndex}}) = {{$trans := getCECCTransitionCondition $block $initVar.VarValue}}{{$trans.IfCond}};
	{{end}}
		
	me->T0 = 0; //???? should this always be 0 ????
	me->Tnext = 0; //this will always be 0, it represents the value of t we've counted to.
	me->Tcurr = 0; //the value of T the solver got to.

	//initialize solver with pointer to values
	flag = CVodeInit(me->cvode_mem, {{$block.Name}}_{{$odeInit.OdeFName}}_f, me->T0, me->ode_solution);
    if (flag < 0) {
		fprintf(stderr, "Error in CVodeMalloc: %d\n", flag);
		while(1);
    }

	flag = CVodeSetUserData(me->cvode_mem, me);
	if (flag < 0) {
		fprintf(stderr, "Error in CVodeSetUserData: %d\n", flag);
		while(1);
    }


	//set solver tolerances
	flag = CVodeSStolerances(me->cvode_mem, reltol, abstol);
	if (flag < 0) {
		fprintf(stderr, "Error in CVodeSStolerances: %d\n", flag);
		while(1);
	}
}
{{end}}

{{end}}
{{end}}