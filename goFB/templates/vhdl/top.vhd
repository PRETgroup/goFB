{{define "top"}}-- This file has been automatically generated by goFB and should not be edited by hand
-- Compiler written by Hammond Pearce and available at github.com/kiwih/goFB
-- VHDL support is EXPERIMENTAL ONLY
{{$block := index .Blocks .BlockIndex}}{{$blocks := .Blocks}}{{$specialIO := getSpecialIO $block .Blocks}}
-- This file represents the top level file for the IEC61499 network with {{$block.Name}} as the top level block
-- This is the file that you should embed into your vhdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity iec61499_network_top is

	port(
		--for clock and reset signal
		clk		: in	std_logic;
		reset	: in	std_logic;
		{{if $block.BasicFB}}{{if $specialIO.InternalVars}}
		--special emitted internal vars for I/O
		{{range $index, $var := $specialIO.InternalVars}}{{$var.Name}} : {{if $var.IsTOPIO_IN}}in{{else}}out{{end}} {{getVhdlType $var.Type}}; --type was {{$var.Type}}
		{{end}}{{end}}{{else if $block.CompositeFB}}{{if $specialIO.InternalVars}}
		--special emitted internal variables for child I/O
		{{range $index, $var := $specialIO.InternalVars}}{{$var.Name}} : {{if $var.IsTOPIO_IN}}in{{else}}out{{end}} {{getVhdlType $var.Type}}; --type was {{$var.Type}} 
		{{end}}{{end}}{{end}}
		
		{{if $block.EventInputs}}
		--input events
		{{range $index, $event := $block.EventInputs}}{{$event.Name}} : in std_logic := '0';
		{{end}}{{end}}
		{{if $block.EventOutputs}}
		--output events
		{{range $index, $event := $block.EventOutputs}}{{$event.Name}} : out std_logic;
		{{end}}{{end}}
		{{if $block.InputVars}}
		--input variables
		{{range $index, $var := $block.InputVars}}{{$var.Name}} : in {{getVhdlType $var.Type}} := {{if eq (getVhdlType $var.Type) "std_logic"}}'0'{{else}}(others => '0'){{end}}; --type was {{$var.Type}}
		{{end}}{{end}}
		{{if $block.OutputVars}}
		--output variables
		{{range $index, $var := $block.OutputVars}}{{$var.Name}} : out {{getVhdlType $var.Type}}; --type was {{$var.Type}}
		{{end}}{{end}}

		--signals in case external components want to measure time
		debug_enable: out std_logic;
		debug_sync: out std_logic;
		debug_done: out std_logic
	);

end entity;

architecture rtl of iec61499_network_top is
	-- Build an enumerated type for the state machine
	type state_type is (STATE_sync, STATE_wait_sync_done, STATE_run, STATE_wait_run_done);

	-- Register to hold the current state
	signal state   : state_type := STATE_sync;

	signal enable : std_logic := '0';
	signal sync : std_logic := '0';
	signal done : std_logic := '0';
begin

	--port map for top level block
	top_block: entity work.{{$block.Name}} port map(
		clk => clk,
		reset => reset,
		enable => enable,
		sync => sync,
		
		{{if $block.BasicFB}}{{if $specialIO.InternalVars}}
		--special emitted internal vars for I/O
		{{range $index, $var := $specialIO.InternalVars}}{{$var.Name}} => {{$var.Name}}, --going {{if $var.IsTOPIO_IN}}in{{else}}out{{end}}
		{{end}}{{end}}{{else if $block.CompositeFB}}{{if $specialIO.InternalVars}}
		--special emitted internal variables for child I/O
		{{range $index, $var := $specialIO.InternalVars}}{{$var.Name}} => {{$var.Name}}, --going {{if $var.IsTOPIO_IN}}in{{else}}out{{end}} 
		{{end}}{{end}}{{end}}

		{{if $block.EventInputs}}
		--input events
		{{range $index, $event := $block.EventInputs}}{{$event.Name}}_eI => {{$event.Name}},
		{{end}}{{end}}
		{{if $block.EventOutputs}}
		--output events
		{{range $index, $event := $block.EventOutputs}}{{$event.Name}}_eO => {{$event.Name}},
		{{end}}{{end}}
		{{if $block.InputVars}}
		--input variables
		{{range $index, $var := $block.InputVars}}{{$var.Name}}_I => {{$var.Name}},
		{{end}}{{end}}
		{{if $block.OutputVars}}
		--output variables
		{{range $index, $var := $block.OutputVars}}{{$var.Name}}_O => {{$var.Name}},
		{{end}}{{end}}

		done => done
	);

	process (clk, reset)
	begin
		if reset = '1' then
			state <= STATE_sync;
		elsif (rising_edge(clk)) then
			--default values
			state <= state;
			enable <= '0';
			sync <= '0';		
			
			case state is
				when STATE_sync =>
					sync <= '1';
					state <= STATE_wait_sync_done;
				when STATE_wait_sync_done => --TODO sync_done signal
					state <= STATE_run;
				when STATE_run =>
					enable <= '1';
					state <= STATE_wait_run_done;
				when STATE_wait_run_done =>
					if done='1' then
						state <= STATE_sync;
					end if;
			end case;	
		end if;
	end process;

	debug_done <= done;
	debug_enable <= enable;
	debug_sync <= sync;

end rtl;
{{end}}
